Saturday September 7th 2013 9:59 am -04:00,I would like to see more exercises as well. They dont have to be part of the course as such but it would be nice if they somehow were related to the topics introduced in the course like additional exercises to a particular topic.Not every topic may need or has to have additional exercises.The exercises do not have to be be graded but they should be accompanied by a solution e.g. in a downloadable pdf.Quite often there are several equally good solutions for a particular problem so the shown solution will just be one possible way to do it. Maybe you could hint at some other approaches or comment on what were the points to look out for. If one really gets stuck the community will certainly be able to help.I am really happy with the course as it is.More exercises would be icing on the cake.,None,3
Wednesday September 11th 2013 9:43 am -04:00,I put this question off until we had seen the for-loop.I looked up the range-bit because I was convinced it could accept more then just one number.This is my version of the program I came up with. Please poke around and let me know where I can improve (or even did err).The program accepts user input so the user can specify the range the stepping (both handled by the range-function) and two divisors. So its a slightly more general version than the initial problem.The int-float-input cascade seems to be necessary to convert negative numbers into int. int-ing a string with a dash before a number (e.g. -50) produces an error. Converting the string to float first and the result to int does the trick.Stepping seems to accept positive numbers only.The program generates two outputs: a vertical list (res_v) and a horizontal comma-separated list (res-h).It concludes with displaying the arguments the user passed to the program.-- begin --print(This program takes a number range and a stepping (start end stepping) and two divisors.Numbers dividable by both divisors will be represented by FizzBuzz dividable by the first specified divisor by Buzz dividable by the second divisor by Fizz. All other numbers represent themselves.)print()res_h = res_v = begin_num = int(float(input(Enter starting number:)))end_num = int(float(input(Enter ending number:)))step_num = int(float(input(Enter stepping:)))divisor1 = int(float(input(Enter divisor1:)))divisor2 = int(float(input(Enter divisor2:)))for i in range(begin_num end_num + 1 step_num):    if len(res_h) > 0:        res_h = res_h +      if len(res_v) > 0:        res_v = res_v +     if ((i) % (divisor1 * divisor2)) == 0:        res_h = res_h + FizzBuzz        res_v = res_v + FizzBuzz    elif ((i) % divisor1) == 0:        res_h = res_h + Buzz        res_v = res_v + Buzz    elif ((i) % divisor2) == 0:        res_h = res_h + Fizz        res_v = res_v + Fizz    else:        res_h = res_h + str(i)        res_v = res_v + str(i)print()print(res_v)print()print(res_h)print()print(Starting number:  + str(begin_num) + ; Ending number:  + str(end_num) + ; Stepping:  + str(step_num) + ; Divisors:  + str(divisor1) +  and  + str(divisor2))print()-- end --,None,1
Wednesday September 11th 2013 10:44 am -04:00,I am a bit puzzled how to deal with the type contract when defining a function based on my code from the previous post.Normally when the function is called with the arguments passed to it at call time the type contract would look like this:(number number number number number) -> strAlready a difference here because at call time the function needs numbers.But because the function is called without arguments [the brackets remain empty: my_fizzbuzz() ] I was wondering what the type contract should look like. On top of that anything entered at an input request is a string thus the inputs are str and not numbers anymore.Thats what I came up with to still have a type contract of sorts:def my_fizzbuzz():     input(str) input(str) input(str) input(str) input(str) -> str   ...However there might be a more generally agreed upon method then my self-made one.What should the type contract look like in this case?,None,0
Wednesday September 11th 2013 11:36 am -04:00,I wasnt so happy that for every iteration of the for-loop I had to pass through the 2 extra if-statements at the beginning of the loop.Thus I pondered a little and came up with the following changes which allows me to ditch the two extra ifs entirely.(I used them initially to not having my strings starting with an unwanted empty line or an unwanted komma-plus-space.)What I am doing now is I ignore the problem until my strings are generated and then cut off the unwanted characters with slicing (we learned this week how to do that).I used this site for speed test: http://www.brython.info/tests/console.htmlFor the tests I hard coded the following values replacing the input strings:begin_num = 1end_num = 10000step_num = 1divisor1 = 5divisor2 = 3The difference in running time:Version 1 (extra ifs): 640ms to 680msVersion 2 (slicing): 410ms to 460msNot having to pass through the 2 extra ifs at every iteration speeds up the execution by one third.Here is the code for version 2:def my_fizzbuzz2():     input(str) input(str) input(str) input(str) input(str) -> str    Request the user to input 5 numbers for begin_num end_num step_num    divisor1 and divisor2. begin_num and end_num define the borders of    the range step_num the stepping. Numbers dividable by both divisors    will be represented by FizzBuzz dividable by the first specified    divisor by Buzz dividable by the second divisor by Fizz.    All other numbers represent themselves.    No examples        print(This program takes a number range and a stepping (start end stepping) and two divisors.Numbers dividable by both divisors will be represented by FizzBuzz dividable by the first specified divisor by Buzz dividable by the second divisor by Fizz. All other numbers represent themselves.)    print()    res_h =     res_v =     begin_num = int(float(input(Enter starting number: )))    end_num = int(float(input(Enter ending number: )))    step_num = int(float(input(Enter stepping: )))    divisor1 = int(float(input(Enter divisor1: )))    divisor2 = int(float(input(Enter divisor2: )))    for i in range(begin_num end_num + 1 step_num):        if ((i) % (divisor1 * divisor2)) == 0:            res_h = res_h +   + FizzBuzz            res_v = res_v +  + FizzBuzz        elif ((i) % divisor1) == 0:            res_h = res_h +   + Buzz            res_v = res_v + Buzz        elif ((i) % divisor2) == 0:            res_h = res_h +   + Fizz            res_v = res_v +  + Fizz        else:            res_h = res_h +   + str(i)            res_v = res_v +  + str(i)            (new line) is just one character => start at the first string index = second string position     komma + space are two characters => start at the second string index = third string positiion         res_v = res_v[1:]      res_h = res_h[2:]    print()    print(res_v)    print()    print(res_h)    print()    print(Starting number:  + str(begin_num) + ; Ending number:  + str(end_num) + ; Stepping:  + str(step_num) + ; Divisors:  + str(divisor1) +  and  + str(divisor2))    print(),None,0
Wednesday September 11th 2013 10:25 am -04:00,Yes this is tricky. The starting index is part of the range but the ending index is not., Resolved,1
Friday September 20th 2013 11:30 am -04:00,Any time soon would be nice!,None,0
Friday October 4th 2013 10:50 am -04:00,I enrolled. See you there!, Resolved,1
Friday October 4th 2013 10:48 am -04:00,I hate that this course is over. After the first week I was eagerly looking forward to the lessons of the next week.Leaned a lot had a good time. You hooked me on Python. I will definitely continue.I am looking forward to you next course!, Resolved,1
