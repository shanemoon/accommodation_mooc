Tuesday September 10th 2013 10:49 am -04:00,ArtyomThe comparison is case-sensitive.You may want to look at the section you use to determine whether the entire sequence is valid.I would also try doing some other tests. Does it work properly for tAG or TaG? Additional tests should help pinpoint where your code breaks.Also I used if... not in... and it worked for me.RegardsNadeem, Unresolved,0
Tuesday September 10th 2013 3:18 pm -04:00,I am getting 3 errors with my get_complementary code. It seems like my test cases cover the error messages unless I am completely misunderstanding the errors.Method Description:Have you tested your function on a zero-length sequence?Message:ERROR: AttributeErrorReplacerModule object has no attribute get_complementary_sequenceMethod Description:Have you tested your function on the example in the handout?Message:ERROR: AttributeErrorReplacerModule object has no attribute get_complementary_sequenceMethod Description:Have you tested your function on a sequence with multiple occurrences        of each nucleotide?Message:ERROR: AttributeErrorReplacerModule object has no attribute get_complementary_sequenceHere are my tests:>>> get_complementary(ACGTACG)TGCATGC>>> get_complementary(ATG)TAC>>> get_complementary()>>> get_complementary(AT)TA>>> get_complementary(AAATTTAAACCCGGG)TTTAAATTTGGGCCC>>> The last 3 tests seem like they should cover the 3 errors.Note I am using my get_complement function in my get_complementary function.Clearly I must be missing something. Any suggestions?ThanksNadeem, Resolved,0
Tuesday September 10th 2013 4:01 pm -04:00,Oh God! Thats embarrassing!I spent so long trying to figure out what was wrong with the code I didnt even think of something that simple!Sorry for wasting your time., Resolved,0
Tuesday September 17th 2013 10:28 am -04:00,In the video there is a demonstration of creating list1 and then setting list2=list1. The video then shows list1 being modified and list2 having the same modification.After some experimentation I figured out the list.copy() method results in a shallow copy of a list that appears to be disentangled from the original list so changes to the original list are not reflected in the copy.I guess my question is why the default would be that setting two lists equal to each other would create entangled lists. It seems like you would more often want to create a disentangled (shallow) copy rather than an entangled (deep?) copy.I suppose this is more a matter of curiosity regarding language architecture than anything else., Resolved,0
Tuesday September 17th 2013 3:02 pm -04:00,Thanks.I think in the past Ive experienced setting one variable equal to another as equivalent to copying it.I didnt take into account how the properties of a variable type might affect that interpretation.Based on the memory address explanation I understood how it would be that way but I didnt piece together the why of it with the explanation of mutability. I think that may be an explanation worth adding to future videos., Resolved,0
