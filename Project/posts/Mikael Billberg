Saturday August 31st 2013 1:49 pm -04:00,Hej!Jag bor strax norr om Stockholm har lång erfarenhet av programmering men behöver lära mig Python.,None,1
Saturday September 28th 2013 12:15 pm -04:00,mikael.billberg@facebook.com, Pinned Approved,0
Friday September 27th 2013 4:19 am -04:00, is a new line character. Yes a new line. So whatever follows a  does not belong to this line but to the next. The string .....line1..... is one string but four lines. (The last three lines are empty.) The for statement will pick one line from the file in each iteration ie one line ending with one ., Resolved,1
Friday September 27th 2013 7:08 am -04:00,I can follow it in the visualizer but I still dont get the logic of append(). Sometimes it appends a copy of a value sometimes a pointer to a value. I cant remember that this is explained anywhere in the course. Aliasing was mentioned but not in enough detail (I think).A guess (I havent verified this) is that it makes a copy when it is a simple value such as a numerical or string but makes a pointer when the value is a list. (Maybe I should try to make up (append) a list with both lists and numerical values as elements and see what I get?), Unresolved,1
Friday September 27th 2013 12:23 pm -04:00,Ive been playing around with IDLE and the visualizer and it seems that when I use append(object) and the object is a numeric value a boolean value or a string value it appends a copy of the object (no aliasing) but when the object is a list it appends a pointer to the object (this object may later be altered due to aliasing).Im not sure if this makes sense in any way but if you have a more specific question I will try to answer it., Unresolved,1
Friday September 27th 2013 3:29 pm -04:00,Yes as long as list1 refers to the appended object any changes to list1 will also happen in list2.One way to break this behaviour is to assign list1 a new value (eg list1 = [3]) then list1 will no longer refer to the object in list2 but to a new object ([3]). Compare what happens when you move the line:inner_list = into the body of the for loop. inner_list is then assigned a new value () in each iteration and cannot change the old object it referred to. Confusing? Yes I think so. To me it seems a high level for a course for beginners., Unresolved,1
Wednesday October 2nd 2013 3:24 pm -04:00,I think that is a reasonable assumption and I dont think this aliasing phenomenon is that well explained in the course.Nevertheless it is possible to follow what happens if you use the visualizer and keep an eye on pairs in every step. What many (most?) of us expected when we read the code was that pairs.append(inner_list) would add a copy of inner_list to pairs. But that is not the case! (It would add a copy of an immutable variable but not of a mutable.) Instead it adds a pointer to inner_list. Then there are two ways to manipulate the inner_list (aliasing) both via inner_list and via pairs. In the next loop inner_list will get two more items stored in the memory space that both inner_list and pairs point to. In the end pairs will have three pointers pointing to the same list. This is hard to explain in only words you have to use the visualizer to get the full picture.The problem seems to boil down to the fact that append() handles mutables and immutables differently and that information is not in the material I have seen so far (no I havent read the Python documentation yet). There is some info though about Mutability and Aliasing in week 5., Unresolved,2
