Tuesday August 20th 2013 7:18 pm -04:00,This has also been an issue for me as well in both this course as well as another course I am enrolled in. My workaround has been to either:When the video ends click next. When that video appears (and subsequently hangs) click Prev (going back to the video you just watched) and then click Next to go to the video you originally wanted to watch.orIt seems that if you do not let the video go all the way to the end and hit Next (e.g. click next about 1 second before the video ends) the next video seems to play as expected., Unresolved,0
Saturday September 14th 2013 2:39 pm -04:00,I think the original delay was created to ensure that in the worst case the number of people submitting could be handled. Could this be throttled back now? Probably.That is what a queue is for not a hard limit., Resolved,2
Sunday September 15th 2013 12:08 am -04:00,To expand on your comment everything you need know about complementing DNA is literally defined in the Problem Domain section of the Assignment 2 Handout., Resolved,0
Sunday September 15th 2013 10:45 am -04:00,Are you using return or print at the end of your functions? You need to make sure you are using return., Resolved,0
Sunday September 15th 2013 12:24 am -04:00,I did mine just a touch different and I like to use parenthesis (and I do this in production code as well) because it helps keep things straight visually as well as explicitly sets the order of operations.edit - I ran across another post asking us to refrain from posting working code until we hear from the instructors. While I dont agree with waiting I will respect the need to wait., Resolved,0
Saturday September 14th 2013 2:51 pm -04:00,I dont know if it was necessary but in addition to my four ifs I also put a check in to make sure that the param that is passed in is in fact a legit nucleotide (ATCG) (call it a habit I guess), Unresolved,0
Saturday September 14th 2013 6:16 pm -04:00,More importantly the statement...if get_complement(A):            return T...is recursive - meaning that the if statement is calling itself over and over infinite times.@William Butler PolettoFirst and foremost you need to use the parameter in your if and elif statements not the function name.## Assuming the word nucleotide is the parameter nameif nucleotide == A    return TIs the proper way, Unresolved,2
Saturday September 14th 2013 6:20 pm -04:00,See my comment above..., Unresolved,0
Wednesday September 18th 2013 7:29 am -04:00,Have you tried running it without the for loop? Also is your parameter literally called nuc?Remember were only trying to find one output for the one inatt so the for statement is kind of overkill. As in param comes into the function if it is this return its compliment. else if it is this other letter return the complementing letter... so on and so forth. You only need to check once. A for statement would be needed if you were looking to check multiple times.Sorry if that was unclear I am on my phone. If you need me to clarify let me know and I will when I get back to my desktop.edit - oh and i forgot to mention just so you know in the future... your for statement is not working because you are not checking the variable you have set in the for loop named chI like to read it out loud to see what it is doing... for each index in the variable nuc set the contents of variable ch to the contents that is at the current index of the variable nuc. So you see since there is only one thing in the variable nuc (the DNA letter) you dont need a for loop., Unresolved,1
Wednesday September 18th 2013 1:01 pm -04:00,Apparently Python is very dependent on indention unlike most other languages Ive used. The conclusion Ive come to is that because there are not line terminators and body encasing characters as there are with say Java the only way Python knows that something belongs to something else is via the indention. Also Ive read that it is best to use 4 spaces and to avoid using tabs.## Here is an example# This is from a1_gui.py in the week 2 Assignment## Note how the FOR statement is all the way to the left and the IF statement# is directly below it indented 4 spaces to the right. Then the body of# the IF statement is directly below that and is indented 4 more spaces# to the right. This indentation and spacing is CRITICAL so that Python# knows what belongs to what and where the body of the statements are.for f in EXPECTED_FNS:    if not hasattr(a1 f):        print(f is missing in a1.py.)        a1.__dict__[f] = lambda *x: 0, Unresolved,1
Wednesday September 18th 2013 1:35 pm -04:00,Coming from a background that includes languages such as C C++ Java C# etc.. all the empty ends of lines and no brackets makes me feel weird lol. I realize it is what it is but for me at least it makes the code harder to read. I know Ill get used to it sooner or later but sometimes it is frustrating., Unresolved,0
Monday September 23rd 2013 4:37 pm -04:00,It seems to work fine for me. Here is the output after copying and pasting your code into IDLE...>>> get_compliment(A)T>>> get_compliment(C)G>>> get_compliment(T)A>>> get_compliment(G)C, Unresolved,0
Wednesday September 25th 2013 10:37 am -04:00,HAH! I didnt even notice the misspelling they made. Good catch!, Unresolved,0
Wednesday September 25th 2013 10:41 am -04:00,If by semicolons (this is a semi colon ; ) you mean single quotes then yes it will return the string output inside single quotes in IDLE. This is expected behavior. If it were an int or a float the displayed output would not be inside single quotes., Unresolved,1
Thursday September 19th 2013 12:31 am -04:00,While I agree that the question as worded would imply (rightly so) that 0 1 2 or 3 times would be correct if you have anything less than 3 times it fails., Unresolved,-1
Thursday September 19th 2013 12:52 am -04:00,@Tom Enos - I agree with your logic. However tell that to the big red X that says that I got the question wrong: https://www.dropbox.com/s/quo1gt0xs6ivie4/week_5_excercise_question_9_bug_ss.jpgHeres the bug report I filed: https://class.coursera.org/programming1-002/forum/thread?thread_id=2257, Unresolved,0
Thursday September 19th 2013 1:32 am -04:00,that is not a bug  you removed to many  if there had been only 3 then your code would have removed the third.What?Even you said earlier...no more then 3 time meansanything less the 4play <= 3only once is okayif it plays only twice it is still okayif it plays 3 times it is okayany more then 3 times it is not okayif it plays any number less then 4 it is okayat 4 it is a failif it plays 1 time and 1 time only it is a passIn my screenshot there are two occurrences of the song title Lola 0 <= 3 == TRUE1 <= 3 == TRUE2 <= 3 == TRUE3 <= 3 == TRUE4 <= 3 == FALSEso on and so forth..., Unresolved,0
Wednesday September 18th 2013 11:17 pm -04:00,@Tom Enos - Anon can test all they want if the last value in their list is an even number (ex. [13572]) all four results will be the same. See this bug report I filed: https://class.coursera.org/programming1-002/forum/thread?thread_id=2255, Resolved,0
Thursday September 19th 2013 1:42 am -04:00,and why post the same thing 3 times in the same thread only minutes apart? @Tom Enos - To give direct replies to the people who posted.it is not a bug if you manipulate the data What data was manipulated?The instructions did NOT give a specific list of numbers to test against. It merely stated that the while_version(L) did something and that the answers which would be the correct for_version(L) function(s) would output the same value that the while_version(L) did.As I showed in my bug report creating a list with odd numbers and then an even number as the last element and then inputting that list into all 4 for_version(L) functions produces the same value as the while_version(L) function., Resolved,0
Thursday September 19th 2013 2:40 am -04:00,Laugh if you want. It would have been more useful to explain why you feel that I am incorrect though. This...it is not a bug if you manipulate the data...tells me nothing., Resolved,0
Wednesday September 18th 2013 11:18 pm -04:00,There is a bug in the code that is supplied. See: https://class.coursera.org/programming1-002/forum/thread?thread_id=2255Make sure to have another ODD number AFTER your even number and you will find the correct answer., Resolved,0
Wednesday September 18th 2013 11:20 pm -04:00,Try these two lists... [123] -> one answer will be different[132] -> all four answers will be the sameThere is a bug in the code that is supplied. See: https://class.coursera.org/programming1-002/forum/thread?thread_id=2255You need to make sure to have another ODD number AFTER your even number and you will find the correct answer., Resolved,0
Thursday September 19th 2013 3:23 am -04:00,Run all five code blocks using the list [132] or [13 243 3 4] or whatever just make sure that the last number in the list is even and that there are no other odd numbers after the even number.If you do you will find that all five results are the same., Resolved,0
Thursday September 19th 2013 12:27 am -04:00,@Kundula Bala Satya Naveen - Then the question should say ...exactly three times... instead of ...at most three times...This has real world implications. If a client/employer required you to write a solution that filtered out results and said the output can only return at most three times that would mean that output 0 1 2 and 3 times are all valid because they are all less than four times... which would fulfill the requirement of at most three times. For example say you are making a music player. We wouldnt have the luxury of knowing what was in the playlist beforehand like we do on this test? How would we be sure that the song Lola was even in the playlist to begin with? Another way of writing the docstring directions Make sure there are no more than 3 occurrences of song in playlist. would be: The occurrence count for the song Lola in the playlist must be <= 3. Thus 0 times would be valid 1 time would be valid 2 times would be valid and 3 times would be valid BUT 4 times would not be valid.If they wanted the song name to be in the playlist exactly three times it must be stated as such. There is no leeway when it comes to < > == <= >= != they are explicit like that for a reason... so there is no confusion., Unresolved,0
Saturday September 21st 2013 11:02 pm -04:00,I dont know if this will help or not (hopefully it does) but think of for loops and while loops in plain English.Say it out loud while looking at the code...while something is true:    do this stuffThis means while something is true keep doing the stuff inside the while block. If it is false quit doing the stuff in the while block and move onA for loop is a bit different in that it will do whatever it is until it is finished iterating through whatever it is that it needs to iterate through... also when iterating through arrays and lists such as a string you can read it like foreacha_string = This is a stringfor each_character in a_string:    do this stuffRemember that the variable that I named each_character is the variable that the for loop will insert the value of a_string  at that moment.So the first time the for loop goes through that code block it will take the T and put its value into each_character. Thus the first iteration would look like this if you broke it out...a_string = This is a stringeach_character = TAfter it is done with whatever it needs to do in the code block the for loop will run through again. Thus the variables would look like this...a_string = This is a stringeach_character = hThis would keep repeating until either you stop the loop manually (using break) or it reaches the end of all the characters contained in the variable a_string whichever comes first.Dont get too hung up on the if/elif/else statements that are happening within the while and for loops because unless you use continue or break (which we havent discussed yet in this class) the while loop and for loopwill continue doing what it needs to do. There is one notable exception to this... if in a while loop you change whatever it that you are comparing true to. So for a simplistic example:num = 0while num < 10:    do something    num = num + 1This will run and check the variable num each time to see if it is less than 10 and if it is do whatever is in the while body. It just so happens that in my particular example I am adding 1 to num each iteration so this particular while statement would run 10 times the first time num == 0 second num == 1 third time num == 2.. ninth time num == 8 tenth time num == 9... the eleventh time though num == 10 which is NOT less than 10 thus num < 10 would evaluate to false and the while loop would NOT do whatever is inside of its code body.This is important! If the statement evaluates to false the while loop will not perform whatever is in its body!Again I hope that clears up some confusion that you might have had. Do not hesitate to ask questions. It is better to ask and understand than to remain confused!Edit - formatting, Unresolved,1
Thursday September 19th 2013 1:11 am -04:00,There seem to be many others here (myself included) who have prior backgrounds in other languages. You might want to consider communicating/partnering up with them so that you could have more direct discussions regarding some of the concepts.This goes for you and anyone else out there who might find yourself in the same position... if you need help do not be afraid to ask! At the very least I will help you. Contact me. Well get on email G+ whatever (I dont have a Facebook acct any longer so that is out sorry) and I will do whatever I can to help., Unresolved,1
Wednesday September 18th 2013 11:15 pm -04:00,The problem summary:The code in the answers supplied all return the same value.Steps to reproduce:Create a list (or hard code the list as the arg) using [13572] making sure the last value is an even number.Run any of the 4 possible answersOutput from any of the the for_version(L) potential answers is the same as the output from the while_version(L) supplied in the question.Screenshot:Output only screenshot:https://www.dropbox.com/s/y9yf7it6ih794vv/week_5_excercise_question_6_bug_ss_output_only_01.jpgIf the professors need a screenshot of the code and the output together I can provide that as well. I did not post it so as to not violate the Honor Code.Notes:The reason it is doing this is because the for_version(L) functions are dropping the even number at the end of the list and not adding it into the previously summed odd numbers. The only way you will receive a different output so that you can answer the question properly is to have another odd number after the even number.Edit - Because I feel like I am banging my head against a wall defending my assertion that there is a bug in the supplied code OR that any issues could potentially be avoided by stating an explicit dataset in a docstring example (as has been taught) I would propose that if a docstring is going to be supplied I feel that it should be consistent with what is being taught because I think that to supply an incomplete docstring when there are results that would go against what has been stated in the instructions is confusing.For example the currently supplied docstring:     (list of number) -> number    Is incomplete. It is being taught that there should be a description and more importantly examples showing the correct output. If an example were to be used in the docstring I feel the entire issue that I have brought to light would be avoided (albeit the code would still be buggy as it does not consistently output what the directions say it is supposed to output.)Thus an example docstring such as: (it could be anything as long as there is an odd number after the even number)     (list of number) -> number    >>> while_version([7 19 21 25 28 35])    72    ...would make it so that almost no one would think to enter a dataset such as...>>> while_version([7 19 21 25 28])72They would simply copy and paste the provided list and use that for the testing in the four code blocks provided in the answers., Unresolved Locked,0
Thursday September 19th 2013 10:38 am -04:00,Here are the directions...The while loop stops as soon as an even number is found and the sum of all the previous numbers is returned.Ok we are good there. No matter what your list looks like because a while loop breaks upon returning false it will end upon hitting an even number.The four functions below use a for loopto try to accomplish the same task although they keep iterating through all of the numbers in L regardless of whether the numbers are even or odd.Ok we are still good. It will act just like the while loop but instead of breaking upon hitting the even number it will just continue on until it reaches the end of the list whether that even number is the last number in the list or not.Only one of them returns the same value as function while_version. Which one is it?This statement is false. I proved it in my tests. All five code blocks return the same value.You make the assumption that one would actually put an odd number after an even number upon further testing. What if they dont? What if they run five tests and the lists look like this:list_1= [1 3 5 7 22]list_2 = [13 15 17 38]list_3 = [95 75 63 41 21 18]list_4 = [1 15 29 55 97 104]list_5 = [5 55 555 5555 55556]Every single one of those will return 5 identical results. What is the person supposed to think when they just ran five legitimate tests and the instructions state that Only one of them returns the same value as function while_version., Unresolved Locked,0
Thursday September 19th 2013 8:34 am -04:00,If you look at my screenshot you will see that I ran three test cases and did indeed find which code block provided the correct answer. I know what the issue is. Ill even provide a big fix if you want.That is not the point though.Ill be honest it is extremely disheartening to see so many people who are arguing for this. It is truly blowing my mind. Furthermore it is making me out to look like a maniac arguing/debating with so many people. The problem is there are many of you who think that this is ok and apparently only one person me who see the issue with this. It sucks feeling like it is me against all of yall. This is not how it should be.So with that said maybe I can present it a different way...How does this help someone who is brand new?Imagine you are brand new at this... this is your fifth week of coding... ever! Youve just been fast-tracked through this weird world of letters and numbers strings and ints ifs and whiles and fors. What the heck is all of this!?!?! It is all so foreign!!!Imagine that this were a real class and this were a real quiz/exam worth real points for a real grade and you had only one shot at getting the answer correct. As soon as you hit submit you are done. No taking back your answers ever. You the new student-coder must do this all without the luxury of many days and multiple retakes. Furthermore because you are sitting in class at exam time you do not have the support of the forums to ask questions about how to tackle an issue should it arise.Now imagine running your tests and you just happen to choose a list of numbers that contain [1 3 5 2]. You run the code and all 5 return the same result! Now what are you to think? You were explicitly told in the instructions that only one code block would match the while_version(L) function but here you sit all five results are the same. What are you to do? Your brain starts racing... Did I mess something up in the code? Did I make a typo when I typed it in there? Is my indention correct? Ive had that issue before maybe its that let me go ahead and re-indent everything and re-run all five code blocks again... this is taking a long time... I hope I dont spend too much time on this one problem. What the heck?!?! It did it again!!! Am I missing something??? I copied and pasted this time. It has to be right! Is their code wrong? They are the professors surely their code is correct. It has to be something I am doing... let me check everything again and see what I messed up. I am so new at this I am confused and have no idea what to think! This is a test so its not like I can just ask someone for help...How long do you think it would take someone who doesnt have the knowledge experience or support that we have here to figure out that it is their dataset that should be changed?What if like you and others have suggested the student happens to decide that they need to run more tests and they decide to run two more tests in addition to the one that they already ran. For the next two times they try it they happen to use the following datasets... [13 43 55 56] then they use [127 153 99 48] then frustrated they decide to run one more test and use [3 99 77 33 44].Every single one of those will produce the same result where all five code blocks will output the same thing.How long if ever do you think it will take that new student to figure out that they need to mix their even number in with the odd numbers so that there is an odd number after their even number?This is where the problem lies.I think that sometimes we are so used to our personal experiences and what we already know that we lose sight of the fact that there are actually those out there especially in these MOOCs who have never seen typed or done anything relating to code. Sure you and I got it. Of course we changed out list of ints so that we could find the answer that they were looking for. Remember the new person though. Remember that they dont know what we know. They might not grasp the logic of it all just yet. You must understand how foreign this must all seem to them. I will bet my income for the next year that almost all the newbies that got this correct right off the bat did so because of sheer blind luck. They just happen to create a list of numbers that had an odd number after the even number thus they happen to stumble across the answer that the test is looking for. That is just bad practice.Would it really be so hard to change the code blocks so that they didnt drop the even number before moving on to the odd? If the code blocks cannot be changed would it be so hard to simply provide an explicit list that the test taker should use so that they dont run into this issue? Which is better making sure that new people taking an introduction course dont run into issues or hoping new people taking an introduction course happen to stumble across the correct answer?, Unresolved Locked,1
Thursday September 19th 2013 10:53 am -04:00,To you it may be obvious. This may not be to others.Take for example someone runs this test:>>> while_version([5 55 555 5555 55556])6170>>> for_version_1([5 55 555 5555 55556])6170>>> for_version_2([5 55 555 5555 55556])6170>>> for_version_3([5 55 555 5555 55556])6170>>> for_version_4([5 55 555 5555 55556])6170Maybe we need more data so we run a different set of numbers...>>> while_version([1 3 5 7 22])16>>> for_version_1([1 3 5 7 22])16>>> for_version_2([1 3 5 7 22])16>>> for_version_3([1 3 5 7 22])16>>> for_version_4([1 3 5 7 22])16Ok that had the same result as the first test. Lets try another...>>> while_version([13 15 17 38])45>>> for_version_1([13 15 17 38])45>>> for_version_2([13 15 17 38])45>>> for_version_3([13 15 17 38])45>>> for_version_4([13 15 17 38])45Still the same result for all five code blocks yet the instructions clearly say:Only one of them returns the same value as function while_version.This is clearly not true because I have shown it to be false in three different test cases.Is it my fault (say I am very new to programming... like all of this stuff is still rather confusing and I am trying to wrap my head around it thus receiving results that correspond to what the directions state would go a long way in helping understand what is going on) or is it the codes fault for violating the rules as provided?This is a bug plain and simple. Just because I can change the data to receive the answer that the test is looking for doesnt make it right. As a matter of fact Id go so far as to state that forcing people to do this (work around some code that violates the provided specs) is a really dangerous line of reasoning. It is teaching people that you should just keep changing your input until you receive the desired output. It should be that the code does not violate the specs so that no matter what you input you will consistently receive the expected output whatever that may be., Unresolved Locked,0
Thursday September 19th 2013 11:20 am -04:00,No because as I showed in my comment above I always returned the same value as function while_version. Did I not? I could have done that all day and each and every single time I would have always returned the same value asfunction while_versionWhy is this not clear? Am I not communicating clearly. I am serious when I say that this is quite frustrating. This has real world implications...Imagine if you will that I have a real world login script. The specification says that it should allow people to always login if they put credentials in that the code on the server accepts and to be denied logging in if the code rejects the user input.Seems straight forward right? If I input my username and password and the server accepts it I should be allowed access to the protected areas. If I input a username and password that the server rejects I should be denied access. So for example if my username was johnsmith and my password was 12345 and I put that into the input boxes and hit the login button if I am in the system as johnsmith and my password is in fact 12345 I am to be allowed access. If I input johnsmith with the password 1234 I should be denied. As a matter of fact as long as I put usernames and passwords that I expect I will always follow the specification provided.What happens when I put johnsmith;DROP TABLE usersWho knows... it could very well be that doing that drops the entire user table. (yes that kind of input is a very real thing. Look up SQL injection) This is because I only expected a certain type of result. You can hopefully see how bad that this would be if an entire table were dropped due to assuming that the user will put simple usernames and passwords into our fields.The code blocks supplied have the same problem in that they assume that the user will input a list that will contain an even number at some point [1:] and an odd number at some point [2:]. What if like me on my first run not realizing this was going to happen a user puts in a bunch of odd numbers with the list ending on an even number and that is it. How many guesses are we expected to make? 1 100 100000? Why is this an issue when the fix is so easy? This is like telling people to not put johnsmith;DROP TABLE users into the username field. It isnt correct... as a matter of fact telling people to change their input to satisfy the output because the code assumes you are inputting a certain thing is plain wrong!, Unresolved Locked,0
Thursday September 19th 2013 1:12 pm -04:00,I dont think you are understanding what I am saying. Maybe it is my fault. Let me attempt to try another more direct and clinical route. I have attempted to be diplomatic and understanding this entire time but now I feel that I must take a more direct and firm stance because I cannot handle this destructive line of reasoning from everyone any longer.The code is flat out wrong! It needs to be corrected if it is to be used for future classes. This is the only way. This is not about the wording of the directions it is about incorrect buggy code. Fixing the incorrect code for future classes should be viewed as the only acceptable solution.Before you dismiss me please I implore you to stick with me hear me out and keep an open mind and hopefully I will convey why the code as written is wrong and should be considered buggy code and given a must fix status.Simply put the resulting output should always follow what is defined in the directions no matter what the input is as long as the input follows the rules for valid input. If the resulting output violates the defined directions it is a bug and needs to be corrected if we are to teach proper techniques of programming. No exceptions!The directions state that there is a while loop and if we input a valid Python list of ints the output will match only one of the 4 for loop code blocks output that are provided as answers. This is not in question.Allowed input for this particular question is a list of ints. Thus whatever Python defines as a valid list of ints is considered valid input. Lets define what an allowed list would be according to Python...From the Python docs: http://docs.python.org/3.2/tutorial/introduction.html#listsPython knows a number of compound data types used to group together other values. The most versatile is the list which can be written as a list of comma-separated values (items) between square brackets. List items need not all have the same type.The above paragraph defines a list as a group (meaning more than one) of comma separated values (items) that is between square brackets. In our case we need a group of items that are more specific. We need a group of ints that are comma separated and that group is contained between square brackets.This means that [1 2] is a valid Python list just like [1 2 3 4 5] is a valid list. Why? Because 1 and 2 are two ints which qualify as a group because together they are more than one number and they are separated by a comma and then fully surrounded by square brackets. This fits all the criteria for being a valid list. The same can be said of 1 2 3 4 and 5 because again those 5 numbers are ints which qualify as a group because all together are more than one number and each item is separated by a comma then the group is fully surrounded by square brackets.Now that we have defined what a valid list is in Python lets look at the directions again...The while loop stops as soon as an even number is found and the sum of all the previous numbers is returned.Ok this is telling us that whatever valid list we input into the supplied while loop the loop will stop when an even number is found and then the function will add all of the numbers it has found and return the sum of the previously added numbers. This excludes the even number because the while loop is stopping and returning at the even number not stopping then adding the existing sum with even number and then returning some value. Pretty straightforward thus far.Lets move on to the information about the for loops...The four functions below use a for loop to try to accomplish the same task although they keep iterating through all of the numbers in L regardless of whether the numbers are even or odd.This is telling us that the for loops is acting just like the while loop except that instead of stopping at the even number it continues iterating through the rest of the list and then is returning a sum of all the values that the for loop iterated through.This is where the main problem can be found! This is not what it is doing. Not counting the for loop that produces an error two of the for loops are iterating through the odd numbers and when it hits an even they simply ignore it and move on. This functionality is broken because these two for loops are acting exactly like the while loop when the list contains all odd numbers with the final number being an even number. This is because it is iterating through the odds and then ignoring the even BUT because the even is the last number the for loop ends thus returning the same exact value as the while loop.Going back to our definition of a valid list and the example list [1 2]. The for loop code that is provided violates the defined rules because using this list will cause all 4 for loops to return the same exact value as the while loop. This directly conflicts with what we were told...Only one of them returns the same value as function while_version.Even if you put the word always in there the code still fails because I can always make it so that all 4 for loops return the same value as the while loop as long as I use a list that is odd numbers ending in an even number. This is a violation. The code should never assume that the user will place another odd number after the even number. Instead it should account for this and work around the input accordingly. There is zero reason why the code cannot do this! No amount of debate will justify not correctly implementing the code especially when it as simple of a fix as adding the even number to the summed total so that each and every time no matter what list of ints you input (as long as it is a valid Python list of ints as defined above) you get one and only one for loop that returns the same exact result as the aforementioned while loop. With all of that said the following would be the proper expected results...If I put in [1 2] it should return 1 in the while loop1 in one of the for loops3 in two of the for loopserror in one of the for loopsThis would follow the defined rule where Only one of them returns the same value as function while_version.If we put in [1 2 3] it should return:1 in the while loop1 in one of the for loops6 in two of the for loops error in one of the for loops. This would also follow the defined rule of Only one of them returns the same value as function while_version.You might think that I am going way overboard with this but you need to realize it is our responsibility especially you as a TA who is looked at as an advocate for proper education to make sure that the people are being taught the proper practices every time all the time not just when it is convenient. If we build a solid foundation by teaching proper practices in the beginning then we in the real world wont have to undo the improper practices that are instilled in people while they are learning when it actually means something and real jobs/time/code/money/etc... are involved. Think about what you all are saying... you are all in essence saying that buggy code is ok as long as you understand its intent. That is flat out WRONG!!! Buggy code is NEVER acceptable if it can be avoided.Do It Right The First Time All The Time!!!, Unresolved Locked,0
Thursday September 19th 2013 12:49 am -04:00,The problem summary:The docstring instructions state: Make sure there are no more than 3 occurrences of song in playlist.. The phrase ...no more than 3 occurrences... means that returning any number less than or equal to 3 occurrences is valid. However the final results state that returning two results is invalid.The phrase ...no more than 3 occurrences... is not the same as ...equal to 3 occurrences... or ...exactly 3 occurrences....Steps to reproduce:Select an answer that outputs a list which results in less than but no more than three occurrences of the song title Lola.Submit test for grading.Screenshot:https://www.dropbox.com/s/quo1gt0xs6ivie4/week_5_excercise_question_9_bug_ss.jpgNotes:Either the docstring instructions should be modified to state that exactly 3 occurrences of the song title Lola are required in the resulting list or the accepted answer(s) should be modified to include an answer that results in a list that has less than or equal to 3 occurrences of the song title LolaEdit - I feel that there is a lot of confusion as to what I am trying to say here and to what my understanding is of the code and its possible intent.As a programmer I realize that there would be no real reason to remove the value once you hit the 3 threshold. I understand that because the >= 3 is causing the code to remove the third instance of the song title the answer would be incorrect. I get it. However my point is that in the instructions given taken at face value without any further criteria removing the third occurrence of Lola would be an acceptable answer because that would be less than 3 occurrences which falls under the no more than 3 guideline.Remember we are afforded the luxury of knowing beforehand what the input is. Knowing this and because we are given a list containing 5 occurrences of the song title Lola it would make < 3 irrelevant and only == 3 relevant. In other words because we know that there are already 5 occurrences of the song title Lola in the original list we know that the list should never contain less than 3 occurrences of the song title. If the docstring were to state something like If there are 3 or less occurrences of the song in the playlist do nothing but if there are more than 3 songs in the playlist remove songs from the playlist until there are no more than 3 songs remaining in the playlist. then it would be far more clear as to what the intent is and all questions/issues would be avoided., Unresolved,2
Thursday September 19th 2013 1:23 am -04:00,One answer throws an error so that is out. Two answers result in exactly 3 occurrences of the word Lola and one answer resulted in 2 occurrences of the word Lola. The last case I described as shown in my ss was marked incorrect.Aside from the answer that threw the error all of the other answers should have been correct as they were <= 3.So for example both:while playlist.count(song) > 3:        playlist.pop(playlist.index(song))while playlist.count(song) > 3:        playlist.remove(song)produced:[Venus Let It Be Lola ABC Cecilia Lola Lola]and this:while playlist.count(song) >= 3:        playlist.remove(song)produced:[Venus Let It Be ABC Cecilia Lola Lola]which was marked as incorrect.As you can see all three resulting lists literally have ...no more than 3 occurrences of song in playlist.edit - FWIW I realize that we are not supposed to show code as it may violate the Honor Code but AFAIK it is impossible to demonstrate the issue otherwise. If there is some other way that I might be able to demonstrate the issue at hand I will gladly do it that way. Also if I need to remove the code let me know and I will do so ASAP., Unresolved,0
Thursday September 19th 2013 1:47 am -04:00,It doesnt matter if it did remove 1 if there were only three. As doing so would still fit the criteria of ...no more than 3 occurrences of song in playlist. There would be 2 occurrences... and 2 is still less than or equal to 3.What you describe is a bug in the code then if the requirement is If there are already three occurrences do not remove any song titlesNo where in the instructions was it said that if there are already three occurrences the code block that is provided should not remove the song title., Unresolved,1
Thursday September 19th 2013 2:00 am -04:00,According to the instructions having only one occurrence of each song would be an acceptable result.Programming isnt about what we feel like returning according to what we feel like the specification says. If you make something to be <= or >= the for loop doesnt just say well I feel that this is enough so Ill just stop. It is exact. How are we to know what the intent is? Maybe they only want 2 occurrences of the song but if there were 3 then thats cool too. They just definitely never want more than three ever. We can only go by what specifications are given to us as programmers.I am not trying to be a jerk I am just saying what the instructions literally say which is at most. This means that anything less than or equal to is acceptable. If they wanted an exact number then that would have been specified.Also I understand what Tom Enos is saying but again his interpretation as to what the spirit of the problem might be was not in the instructions either. His interpretation was If there are already three occurrences of the song in the playlist stop removing songs. I am saying that if that is what is needed that should be clearly defined in the instructions. Otherwise it falls back to ...no more than 3 occurrences of song in playlist. which means that no matter what anything that is equal to 3 or less than 3 is an acceptable answer... even if you have only three and remove one., Unresolved,0
Thursday September 19th 2013 2:07 am -04:00,The list will be untouched if it contains the song for 0 1 2 or 3 times.Where in the instructions does it state this?Take a list that has a song for 3 times. The list satisfies the condition that it has the song no more than 3 occurrences and hence list need no modifications but the code with >= modifies the code by removing the song which makes it invalid.Thatis your assumption.According to what  the instructions literally say:Here is an example of their playlist:[Lola Venus Lola Lola Let It Be Lola ABC Cecilia Lola Lola] You want to make sure that Lola gets played at most 3 times so you want to complete this function that edits the playlist:def cap_song_repetition(playlist song):    (list of str str) -> NoneType    Make sure there are no more than 3 occurrences of song in playlist.    Nowhere in those instructions does it say that if the list already contains 3 occurrences of the song title either do not remove it or stop removing songs.Edit - To put it another way if the instructions said:You want to make sure that Lola gets played 3 times so you want to complete this function that edits the playlist:Then having Lola in the list 3 times no more and no less would have been what was expected and the >= 3 answer would be incorrect because it iterates through and removes too many occurrences of the song leaving only 2 occurrences in the list.But they dont say that...As the instructions are stated and this is important even if you removed all occurrences of the song thus leaving 0 occurrences of Lola in the list that answer would have been correct as well., Unresolved,1
Thursday September 19th 2013 2:31 am -04:00,I dont know where(& why) you are confusing. The wording Make sure there are no more than 3 occurrences of song in playlist. says that.Ask yourself...Is 0 no more than 3 occurrences?Is 1 no more than 3 occurrences?Is 2 no more than 3 occurrences?Is 3 no more than 3 occurrences?Whichever questions you can answer Yes to would be the correct answer. No matter what.If I have 6 occurrences and I remove 3 so that I have 3 left in the list I have made sure that there are no more than 3 occurrences of the song in the playlist. Also if I have 6 occurrences and I remove 6 so that I have 0 left in the list I have made sure that there are no more than 3 occurrences of the song in the playlist.Nowhere does it say that I have to leave even one song in the playlist. It just so happens that the code provided does this., Unresolved,1
Thursday September 19th 2013 3:16 am -04:00,The docstring Make sure there are no more than 3 occurrences of song in playlist. is exactly like...if song in playlist > 3 then execute the statement. Nowhere in the instructions did it say how many times the statement was supposed to execute. Furthermore Make sure there are no more than 3 occurrences of song in playlist.  is not the same as saying if song in playlist is > 3  The statement Make sure there are no more than 3 occurrences of song in playlist. is saying if there are more than 3 occurrences of the song in the playlist remove them but if there are 3 or less occurrences of the song in playlist that is what we want as there are now no more than 3 occurrences of the song in the playlist.To illustrate my point...If I told you that I have no more than $20 in my pocket could I potentially have $20 in my pocket? Yes. Could I potentially have $21 in my pocket? No. Why? Because I literally said that I have no more than $20 in my pocket and $21 is more than $20. Additionallyif I said I had no more than $20 in my pocket could it also be that I potentially have $14 in my pocket? What about $0? Yes and yes as both of those amounts are also no more than $20 therefore I could potentially have either of those amounts in my pocket.With that said if I were to tell you to remove money from my pocket so that I have no more than $20 in my pocket since leaving $20 $14 and $0 would be considered leaving no more than $20 in my pocket; without explicitly defining when you are supposed to stop removing money from my pocket you could feasibly end up removing all the money from my pocket because again $0 is no more than$20.So when the instructions say to make sure there are no more than 3 occurrences of the song in the playlist and they provide code that ends up removing songs from the playlist until there are only 2 songs left in the playlist that is a correct answer becauseleaving 2 occurrences in the playlist is literally making sure that there are no more than 3 occurrences in the playlist. If they had an answer that left 4 occurrences in the playlist that would be an incorrect answer because leaving 4 occurrences in the playlistis in fact leaving more than 3 occurrences in the playlist. If they had happen to have provided a code block that left 0 songs in the playlist with the defined instructions that code block would also be a correct answer because leaving 0 occurrences in the playlist is also making sure that there are no morethan 3 occurrences of the song in the playlist., Unresolved,2
Wednesday September 25th 2013 1:58 am -04:00,It probably is a path issue. I found that Python can be kind of a pain when it comes to using a path to open files. Try using the tkinter package that the instructor uses in the lectures this way you can manually select the file you are attempting to use.Here is a code snippet:import tkinter.filedialog# if you are using a separate file for your function dont forget to import itex_filename = tkinter.filedialog.askopenfilename()ex_file = open(ex_filename r)# Put your code here...ex_file.close(), Resolved,2
Saturday September 28th 2013 8:27 pm -04:00,First and foremost you spelled it incorrectly. (Hence your syntax error)# Notice you have an n after the o in open.tkinter.filedialog.askonpenfilename()It should be spelled like this:tkinter.filedialog.askopenfilename()Secondly it is best (for what we are doing in this class) to put the filename into a variable first then reuse that variable to open your file:some_filename = grades_filename = tkinter.filedialog.askopenfilename()some_file = open(some_filename r)Finally if I am not mistaken you cannot import stuff into the IDLE Shell. You need to use import statements in a pythonfile (file.py).Edit - Formatting, Unresolved,1
