Monday August 19th 2013 8:30 pm -04:00,Just around 5:54 after first questions of the quiz the video stalls making the chrome browser unresponsive. Up until that point it accepts my answers correctly (marking them correct when correct and wrong when wrong) then stalls. Ive tried it in a single open window and with other windows open (coursera and the course window) neither seems to have any effect and both are active up until the video reaches that point and stalls. I forgot to mention that Im using chrome Version 28.0.1500.95 m. and that it doesnt seem to occur in Internet explorer. Im really not an IE fan though so hope this isnt a common issue. , Unresolved,0
Tuesday August 20th 2013 7:18 pm -04:00,Hi Robab One of the noticeable differences that Ive observed between face to face classes and technology supported/online courses is that in terms of group collaboration in face to face courses Ive noticed groups fall through on their collaboration when they were not able to meet to work on activities together at a convenient time-slot. In moocs and other online courses that Ive taken Ive noticed that as classmates became more and more familiar with the online communication tools being used in collaboration fewer teams seemed to depend on the anticipation of set meeting times gradually working toward projects in a more asynchronous manner: planning assigning completing and compiling individual activities toward a single wrap up meeting that most of the team members usually made time to attend.As time passes it seems likely to me that this will be a recurring trend.  ,None,2
Tuesday August 20th 2013 5:50 pm -04:00,Just a small note Theres also the practice page from the course wiki. ,None,5
Wednesday August 21st 2013 7:43 pm -04:00,Here is my attempt using sequencing. (Actually I meant indexingthere.),None,0
Thursday August 22nd 2013 10:22 am -04:00,Out of curiosity I unsuccessfully tried a version using a comprehension: #Globalssequence = #Functionsdef vari():    frst = int(input(Enter the first number of your sequence.))    scnd = int(input(Enter the second number of your sequence.))    its = int(input(Enter the length of your sequence.))    fibo(frstscndits)    print(sequence)    def comp(x):    com = x[-2] + x[-1]    return com    def fibo(frstscndits):    global sequence    sequence.append(frst)    sequence.append(scnd)    sequence =[ comp(sequence) for i in range(its)]    return sequencevari()Any thoughts on why its only returning the value of the first number doubled?On a side note I did try sequence using  the indexs in the comprehension but to the same result: sequence = [[sequence[-1] + sequence[-2] for sequence[-1] in sequence for sequence[-2] in sequence] for i in range(its)]Even when I used a zip between step 14 and step 15 something is occurring that changes the value of the sequence[-1] to whatever the value for sequence[-2] is. ,None,2
Thursday August 22nd 2013 7:53 pm -04:00,Hi Christos Thank you Your suggestion does take it alot closer to the goal!But something happens again between step 41 and 42 that sets the appended value to none. I think that I understand a little of the logic of why the change to include the append function inside of the comprehension lets the list build though...If Im not mistaken the reference to sequence stays internal or local to the comprehension and each value of the list is added as a group at the end instead of individually so that the [-1] and [-2] indexs always point to the same values. Im still not sure I get why the value[-1] changed to equal value[-2] at fourth step in the earlier version. ,None,0
Thursday August 22nd 2013 8:10 pm -04:00,In this version it seems to happen between steps 33 and 34 due to the assigned values of the variables. It seems to happen between the completion of the comprehension and the return sequence command. ,None,0
Sunday August 25th 2013 8:33 pm -04:00,Hi Christos  I took you suggestion but it went back to returning none for each element of the response in the visualizer; however it works in the python portable version that Ive downloaded. Thank you for the tip. ,None,0
Tuesday August 20th 2013 7:04 pm -04:00,I may have missed the forum link for the wiki practice exercises and apologize if so but in any event - here are my attempts at the problems for weeks 1-2 using the visualizer: ,None,0
Thursday August 22nd 2013 8:07 pm -04:00,Aside from different variable choices I think that ours were mostly the same but did notice a slight difference with regard to the average function can I ask why you used 4 in your code instead of two? From # Practice Weeks 1-2# Solved by Alexander B.(Beleno) Falguidef average(x y):    return((x + y) / 4),None,0
Wednesday August 28th 2013 12:28 pm -04:00,Hi BrunoTo simplify the search loop a bit you could format the phrase to lowercase using ...phrase = phrase.lower()and constrain your check to a single set of 26 characters.  I think you may need to add a greater sign to the  shift calculation - similar to ....    if b + shift >= 26:        t = int((b + shift) % 26)    else:        t = int(b + shift)to loop the shift back around to the beginning of the alphabet if it exceeds an index range of [0 ... 25] and shifted both sets of letters. ,None,0
Wednesday August 28th 2013 8:09 pm -04:00,Being more than a little unfamiliar with ascii table and character set I had to take a look at them for a bit to get a clearer idea of how you were using the  > code < ranges. As youre doing it I can see that my suggestion wouldnt apply. While I am a beginner (as being unfamiliar with ascii tables probably shows) I think that there may also be different approach to python between my interpretation and yours. (Ignoring the functions0 I have a tendency to write shorter simpler functions to chunk the tasks youve taken care of in one function- and Im looking for simpler still.As it is Im playing around with this one to try and revise the loop into a comprehension to iterate through the shift in one line. ,None,0
Wednesday August 28th 2013 12:00 pm -04:00,My Cipher.Any thoughts? Other than loops lists ranges .appending and  .join() -- I think Ive avoided a lot of topics we havent covered yet (like string slicing and dictionaries).  (Yes that was said/written with a bit of tongue in cheek in mind). ,None,0
Thursday August 29th 2013 1:27 pm -04:00,Hi Lakka I am playing with an ascii version to get a better understanding of the ascii table. With regard to why nothing is being returned is that in this version I forgot to add the function call to caesar() which this link includes. Other than adding an assignment to the globals segment as an alternate to the random test thats the only change i made in the code. ,None,0
Thursday August 29th 2013 2:07 pm -04:00,Hi Bruno Thanks for pointing out the error with the shift. It was carelessness in my part not adding the alternate global definition for shift in place of the random value assigned to shift that was commented out. The global assignment of shift was a carry over from using the random assignment to test the functions at multiple stages that I was careless and forgot to take out when I added the  local input at caesar() although Ironically i did remember to take the global shift out of that function. With regard to the caes empty stringat some point when I was working on translate phrase function if I didnt leave an empty space as an element the first character was always returned without any processing (Im not sure why) but when I added the space it processed as intended. As I noted to Lakka I am playing with a ascii version to get the idea down but want to work on the comprehension first.Hmmm. Youre right of course on the assignment to d Im not certain why I didnt see it. One think I do try to look for is duplication of terms. Only excuse I have is a lack of coffee at that time. :),None,0
Thursday August 29th 2013 8:16 pm -04:00,Well the comprehension version worked: import randomimport stringshift = random.randrange(26)alpha = string.ascii_lowercasealfa = {} cae = def alph():     Creates a dictionary using alpha(a-z) as keys and range(26) as values    global alfa    alfa = {x:y for xy in zip(alpharange(26))}    return alfadef bldg_shft(ch):     (chr) -> chr : (dictionary value + shift) is used as index for the new chr.    if ch in alpha:        key1 = (alfa[ch] + shift) % 26        return alpha[key1]    else:        return chdef translate_phrase(phrase):    (string) -> string: Using a comprehension to build the encrypt the string entered.    cae = .join([bldg_shft(ch) for ch in phrase])    return caedef caesar():    alph()    phrase = (input(Enter the phrase you would like to encrypt)).lower()    shifted = (translate_phrase(phrase))    print(shifted        shift)    caesar()On to the ascii version. :),None,1
Friday August 30th 2013 5:43 pm -04:00,Mysterious.... Somehow that was one adjective I didnt expect. But. I have to admit a nice compliment. Thank you. ,None,0
