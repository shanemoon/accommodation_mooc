Friday September 13th 2013 12:44 pm -04:00,An Introduction to Interactive Programming in PythonGoddamn...how to live on when the course is finished? Ive been trying to wear tie...believe me it doesnt help much..., Pinned Approved,0
Sunday September 8th 2013 11:34 am -04:00,My attempt. Ive tried to do it faster. On my computer (Ubuntu 13.10) direct algorithm takes approximately 70 seconds. My idea is to exclude numbers from input array based on previous calculations. Briefly if chain x contains numbers [n1 n2 n3 ....nm] we can exclude these numbers from input array for next iteration. The same way we could exclude all even numbers equal to n1*2**m where n1 is a first (starting) number from chain and m is a natural number such that n1*2**m <= max(N) where N is an input for the algorithm (e.g. 1000000 in our case). We could than organize this numbers as a list and add this list to the chain that was found during current iteration. We should store only longest chains so we could clear the set storing the chains to store only longest of them. After len(n) decrease to some threshold the efficiency of algorithm (likely) approaches the efficiency  of direct algorithm (you can see it if you uncomment few lines with for and print statements near the end of the code). But I cant say it for sure because unfortunately I havent have time for that research (see explanation bellow). Im sorry this code is probably not ideal. But me and my wife have wedding anniversary today and she is very angry that Im coding instead to celebrate our day :). Thanks for your time. Happy codding! :)def hailstone_seq(n):    n = [n]    while n[-1] > 1:        n.append(n[-1]%2 == 0 and int(n[-1])/2 or int(n[-1])*3+1)    return n      def collatz(n):    n = set(range(1 n+1))    chains = set()    maxlen = 1    N = max(n)    #i = 1    while len(n )>= 1:        #i +=1         hs = hailstone_seq(n.pop())        if hs[0] >1:            while hs[0]*2 < N:                hs.insert(0 hs[0]*2)        if len(hs) > maxlen:            maxlen = len(hs)                        chains.clear()            chains.add(tuple(hs))        elif len(hs) == maxlen:            chains.add(tuple(hs))        n -= set(hs)              #if i%(0.1*N) == 0:        #    print(str(i)+ iterations done.  + str(100*len(n)/N) + %  of n left)    for i in chains:        print(Longest total stoping time found for the number  + str(i[0])+                 .Length of Hailstone sequence is  + str(len(i)) + . Maximum number apearing in sequence is  +                 str(max(i)))    #return chains  ,None,0
Tuesday September 10th 2013 4:00 pm -04:00,Naive algorithm:import mathdef naive_test(n):    primes =     while n >= 2:        dividers =  set(int(math.sqrt(n)) < 2 and [2] or [i for i in                        range(2 int(math.sqrt(n) + 1)) if i == 2 or i%2 != 0])              for i in dividers:            if n != 2 and n%i == 0:                break        else:            primes.insert(0 n)        n -= 1            return primesIts more or less fast close to 10000. It takes 5.959 seconds to find primes in range 2...100000. I tried it for 1000000 and interrupted it after 125 seconds. Prime numbers they are soooo coool!!!1 ^__^,None,0
Wednesday September 11th 2013 2:04 pm -04:00,Naive algorithm update. Second function (naive_fast) accelerate naive algorithm. It tests if number is divisible by 2 or 3 and only if it is not function tests the dividers of form 6*i +- 1 such that 6*i +- 1 <= int(sqrt(n)) for i = 1 2 3....int(sqrt(n))+1. Im not sure about the right limit for n...I think about it latter to update the code.import mathdef naive_fast(n):    primes =     while n >= 2:        if (n != 2 and n!= 3) and (n%2 == 0 or n%3 == 0):            n -= 1            continue        else:            if (dividers in vars()) and (dividers !=  and dividers[-1]**2 > n):                del dividers[-1]            elif not(dividers in vars()):                dividers = [6*i + j for i in                            range(1 int(math.sqrt(n)) + 1) for j in [-1 1]                                               if 6*i + j <= int(math.sqrt(n))]            for i in dividers:                if n !=2 and n != 3 and n%i == 0:                    break            else:                primes.insert(0 n)        n -= 1    return primes,None,0
Wednesday September 11th 2013 6:14 pm -04:00,Yes because its a naive algorithm. So its not very smart. It uses very simple idea that composite numbers are multiples of 2 or 3 and other prime until they are not multiples of other prime numbers. According to the Wiki article (see the link in my post) all natural numbers can be represented as 6*k+i where k is integer and i = [-1 0 1 2 3 4]. Only in case if i = -1 or +1 it is not divisible by 2 or 3. So in 2/3 of cases function find composite number just testing the number for divisibility by 2 or 3:# R script for dividers visualization counting for 4...10000. Slow. # btw very good joke about the R accent I like it :)require(ggplot2)div <-  c()for(i in 4:10000){    if(i%%2 == 0){        div <- c(div 2)    }else if(i%%3 ==0){        div <- c(div 3)    }else{        div <- c(div other)    }   }div <- data.frame(Dividers = factor(div levels = c(2 3 other)))table(div$Dividers)g1 <- ggplot(div aes(Dividers fill = Dividers)) +       geom_bar(stat = bin) +      scale_fill_discrete(name=Dividers fornumbers 4...10000)             png(dividers.png)print(g1)dev.off()  And off course we dont need to test dividers greater than square root of n because multiples founded above this limit always include factors we found before. Slow algorithm in my code exclude only even numbers and then does primarlity test for all possible dividers up to sqrt(n). Fast algorithm test every number for divisibility by 2 an 3 and only if n not divisible by 2|3 function creates the list of dividers and performs primality test for n against these dividers. It creates the list only once and then just removes the biggest elements from the list if they doesnt fit to sqrt(n). To be clear: I dont think that its very good cod etc. Im just trying to reproduce what I have read about it step by step. ,None,0
Wednesday September 11th 2013 6:32 pm -04:00,For functions its a cProfile module:import cProfilecProfile.run(yourFunction(argument))For scripts I have found answer only for shell:python -m cProfile yourScript.py,None,1
Friday September 13th 2013 2:27 am -04:00,Sieve of Eratosthenes:## upd: I decided to test all numbers not only odd - in this case code a bit slower.import mathdef erath(n):    primes = list(range(2 n+1))    i = 0    while primes[i] <= int(math.sqrt(n)):        primes = [j for j in primes if j <= primes[i] or  j%primes[i] != 0]        i += 1    return primes,None,0
Friday September 13th 2013 6:53 am -04:00,Ive tested my functions on Windows machine. Results:#Data from cProfile testn       naive_slow      naive_fast      erath10      0.000   0.000   0.000100     0.002   0.000   0.0001000    0.023   0.005   0.00310000   0.219   0.036   0.037100000  4.913   0.359   0.2661000000 152.738 7.986   5.3215000000 1660.061      97.253    49.02910000000        NA      323.954 140.04820000000        NA      1372.126      342.810# R scriptrequire(ggplot2)require(reshape)DF <- read.table(prime_test_time.txt header = T)DF <- melt(DF id = n)graph <- ggplot(DF aes(x = n y = value colour = variable)) +    stat_smooth()+    geom_point(size=2shape=21fill = white)+    xlab(N) +    ylab(Time seconds)+    scale_colour_discrete(name  =Algorithm:                            breaks=c(naive_slow naive_fast erath)                            labels=c(Naive (slow) Naive (fast)                                     Sieve of Eratosthen)) +    theme(legend.position=c(0.86 0.905))pdf(prime_time.pdf)print(graph)dev.off()In log scale:,None,0
Wednesday September 18th 2013 6:59 am -04:00,count me in,None,0
Friday September 20th 2013 6:27 pm -04:00,gosh...my English sucks - didnt guess red. how could it be? nice game Ravi! :),None,0
Friday September 20th 2013 1:05 pm -04:00,My attempt (with comments). Works for me under Ubuntu and Windows hope it works for Mac also. Its better to run the program in terminal because in IDLE it keeps printing new lines. Just save it like hangman.py and run:> python3 hangman.pyUnder the Windows with installed python shell it starts after double click on hangman.py file.You can download the script file here: https://gist.github.com/utubun/6641138import random sys os urllib.requestdef clr():        Get the information about OS. Clear the screen using the appropriating    command for this operation system        if str(sys.platform.strip(2346)) == win:        os.system(cls)    else:        os.system(clear)def hm_draw(flag reset = False):        (bool bool) -> bool    Use list mtrx to adjust print statement for drawing the gallows.    Returns False if the last guess was made. Returns True othervise.    False is used to break while loop in hangman(). Reset    parameter is used to reset function if the word is guessed.        global j    if not(j in globals()):        j = 0    if reset:        del j        return None    if flag:        j += 1    mtrx = [[00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]            [0 1 0 0 0 1 0 0 1 0 0 0 0 1 0 0 0 0 1]            [7 1 0 0 0 1 0 0 1 0 0 0 0 1 0 0 0 0 1]            [7 1 1 0 0 1 0 0 1 0 0 0 0 1 0 0 0 0 1]            [7 1 1 0 0 1 4 1 1 0 0 0 0 1 0 0 0 0 1]            [7 1 1 0 0 1 4 1 1 4 0 1 0 1 0 0 0 0 1]            [7 1 1 0 0 1 4 1 1 3 1 1 0 1 0 0 0 0 1]            [7 1 1 0 0 1 4 1 1 3 1 1 1 1 0 0 0 0 1]            [7 1 1 0 0 1 4 1 1 3 1 1 1 1 3 1 0 0 1]            [7 1 1 0 0 1 4 1 1 3 1 1 1 1 3 1 1 1 1]            [7 1 1 3 1 1 4 1 1 3 1 1 1 1 3 1 1 1 1]]    i = mtrx[j]    clr()    print(_*i[0]+  +          | *i[1] + / *i[2] +  *i[3] + |*i[4] +  +          | *i[5] +  *i[6] + O*i[7] +  +          |*i[8] +  *i[9] + /*i[10] + U*i[11] + \\*i[12] +  +          |*i[13] +  *i[14] + /*i[15] +  *i[16] + \\*i[17] + +          |*i[18])    if j == 10:        del j        return False    return Truedef en_words():        () -> list    If file containing English words is not present - function downloads file from the web.    After the file been downloaded function reads the file wordsEn.txt creating the words    list. Prints the error message if the file cant be downloaded and is not present in    current directory. Returns None in this case.        try:        if not os.path.isfile(wordsEn.txt):            print(Donwnloading the English dictionary please wait...)            url = http://www-01.sil.org/linguistics/wordlists/english/wordlist/wordsEn.txt            urllib.request.urlretrieve(url wordsEn.txt)            print(Done!)        f = open(wordsEn.txt)        words = [f.readline().strip() for lines in f]        f.close()        return words    except IOError:        print(Oh Lord there is something wrong with me. I cant find wordsEn.txt file. Please check your internet connection)        return Nonedef hangman(secret guess):        (str str) -> str    This function takes secret word and users guess and if user guess (single character) is found in secret word    it calls hm_draw() function with flag = False (draw the same image). It also displays secret word in form    _ _ _ e d showing the letters guessed by user and asks user to guess next letter. If user guess is wrong it    calls hm_draw() with flag = True. With True arguement hm_draw() adds next element to the gallows.    hm_draw() assigns False or True to the continue_game variable. When the last element of the gallows is added    it returns False and hangman() prints whether the user won or lost this round. After that it asks user if she/he    would like to continue the game.        continue_game = True    display = - *len(secret)    flag = False    while all(guess)!= True:        continue_game = hm_draw(flag False)        if (not continue_game) and (not all(guess)):            print(You lost this round...I guessed word %s!  % secret.upper())            usr_answr = str(input(Do you want to try it again? Enter y if yes or push the Enter to quit: )).lower()            return usr_answr        flag = True        print(The word is %s % display)        letter = str(input(Guess the letter: )).lower()        display =         for i in range(len(secret)):            if letter == secret[i]:                display = display + letter +                  guess[i] flag = True False            elif letter != secret[i] and guess[i]:                display = display + secret[i] +              else:                display = display + _     print(You win! %s is a secret word! % secret.upper())    usr_answr = str(input(Do you want to try it again? Enter y if yes or push the Enter to quit: )).lower()    hm_draw(False True)    return usr_answrdef start_game():        Simple loop designed for playing several games if user answer is Yes (y). At the begining    this function creates the list of words prints welcome message and asks user if she/he/it wants    to play the game. In the body of the loop function randomely chooses secret word from the word list    arrange guess as list filled with False and with len(guess) == len(secret). It asks user every    time the round is finished if she/he/it/somethingfromotherworld wants to continue.        words = en_words()    usr_answr = str(input(Welcome to the Hangman game! To start the game type y. Type any other character to exit the game. Enter your answer here: )).lower()    while usr_answr == y:        secret = words[random.randint(0len(words))]        guess = [False]*len(secret)        usr_answr = hangman(secret guess)    #######################################START##THE##GAME#############################################start_game(),None,3
Friday September 20th 2013 3:44 pm -04:00,Thank you Tom!,None,0
Friday September 20th 2013 4:39 pm -04:00,Thanks! I have started from tons of if-elif-else statements...but then I decided that its not cool)) Ive seen your post where your proposed to use list of graphical elements only today. It impress me very much every time when Im realizing that people from different locations thousands km from each other got similar idea at the same time. ,None,0
Saturday September 21st 2013 11:38 am -04:00,Thank you Bruno I appreciate it very much. Yes you right. It is because clr() run os.system(cls/clear) command. I have realized that it wont work in IDLE the way I want it to be so from the beginning I decided to wright it like a game for console. It works under the IDLE also but as youve seen it prints new lines after each user guess. ,None,0
Saturday September 21st 2013 1:17 pm -04:00,:) its gonna be cool! ,None,0
Saturday September 21st 2013 6:07 am -04:00,Yes thats very cool! Your code is #1. But classes tkinter...this looks very odd in Learn to Program: Fundamentals discussion forum. What would people think? :) Ok next time I do it with classes also. Have no experience with tkinter but I must try it /,None,0
Saturday September 21st 2013 10:35 am -04:00,Let me guess it....Yes! In Recomended Reading tread Tom has mentioned this course :) And this style of coding reminds me the style of Interactive Programming... course.,None,0
Saturday September 21st 2013 1:13 pm -04:00,Its definitely a good choice Ravi! An Introduction to Interactive Programming in Python is one of the best courses Ive completed so far. And after you finish the course youll miss it I promise you )) ,None,2
Saturday September 21st 2013 6:38 am -04:00,Next game we must write is Zork! Dont tell me that we cant do that! ,None,0
Wednesday October 2nd 2013 10:23 am -04:00,we dont have extraweek challenge #7? did i miss something?,None,0
