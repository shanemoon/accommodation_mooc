Wednesday August 28th 2013 10:45 pm -04:00,Looks good but I agree in that it would be much simpler to use ascii then write your own array of letters.,None,0
Wednesday August 28th 2013 10:42 pm -04:00,Hello!Here is my super simple code. It doesnt work for capital letters but Im confident I couldve added it with a bit more work. Spaces are also very obvious in it. Tell me what you thinkcaesar_cipher(sentence shift):    (str int)-> str    This function will return an encrypted sentence using a caesar cipher with shift given    It can also be used to decode a sentence if the shift is known by using -shift        encrypted_sentence =     for letter in sentence:        new_letter = chr(ord(letter) + shift)        if ord(new_letter) > 122:            new_letter = chr(ord(new_letter)-26)        encrypted_sentence += new_letter    print(encrypted_sentence),None,0
Friday August 30th 2013 12:03 am -04:00,I like yours better Lakka. Thanks for the feedback.,None,0
Friday August 30th 2013 1:02 am -04:00,Well in your example the shift would always be between 5 and 9 and for any key it would be a value between key and key + (key-1) so it is still just a shift. Of course it might make it a tad bit more difficult for someone who didnt have access to the code.,None,0
Thursday August 29th 2013 12:17 am -04:00,Hello here is my attempt:def round_trip():    time = time_to_go(place1) + time_to_go(place2) + time_to_go(place3) + time_to_go(place4)    hours = int(time/60)    minutes = int(time - hours*60)    seconds = int(time*60 - hours*3600 - minutes*60)    print(hours minutes seconds)Im having two problems. 1) Do you even need to use the function next_place()? I didnt need to. 2) I tried using this for printprint(hours + : + minutes + : + seconds + :)so the colons would show up as you requested but it gives me a syntax error. Any comments are appreciated thanks!,None,0
Friday September 6th 2013 10:39 am -04:00,I dont know who voted you down. This is really good stuff. Really helped me out for the second part. Just wondering if theres any way to do the length and largest number functions you did with a recursive function. Anyways thanks a lot you are a great coder.,None,0
Friday September 6th 2013 10:00 am -04:00,Your collatz is very similar to mine. You can replace the two seperate counter = counter+1that are in your code by putting counter += 1 before or after the print. This will also eliminate the need to add 1 to your final print call.,None,1
Friday September 6th 2013 10:18 am -04:00,Heres my code for #1)def collatz(n counter largest):    print(n)    counter += 1    if n == 1:        return counter largest    elif n % 2 == 0:        if n > largest:            largest = n        return collatz(n/2 counter largest)    else:        if n > largest:            largest = n        return collatz(3*n+1 counter largest)I decided not to do #2 since I couldnt figure out how to do it until I looked at others code so me writing it out would kind of just be copying....,None,0
Friday September 6th 2013 10:40 am -04:00,Also I thought you werent supposed to discuss project euler questions anywhere :P JKJK,None,0
Thursday September 5th 2013 9:32 am -04:00,If you like mathematical programming try project euler (google it). They are very tough and should give you some help there are many websites that have programming challenges on them as well.,None,3
Wednesday September 11th 2013 2:24 pm -04:00,So is this essentialy a sieve that only applies the sieve to multiples of 2 and 3?,None,0
Wednesday September 11th 2013 7:28 pm -04:00,Yup thats what I was asking thanks for the reply. Im gonna try and implement a sieve similar to the one ravi did which is very good.,None,0
Wednesday September 11th 2013 2:26 pm -04:00,Here is my naive prime generator. I will work on applying a sieve in a couple of hours. Im not sure where to start so it could take me a while. Im also not sure how to test the time it took the computer to run the script anyone can help here?def is_prime(n):    (int) -> bool    Returns true if n is a prime number.    Precondition: n must be greater than 2 and an integer    >>> is_prime(13)    True    >>> is_prime(100000007)    True    >>> is_prime(262144)    False            import math    i = int(math.sqrt(n)+1)    if n == 2: return True    else:        for x in range (2 i):            if n % x == 0:                return False    return Truedef naive_prime_generator(n):    (int) -> array    Generates an array/matrix containing all the primes from 2 to n using a naive (inefficient) method    >>>naive_prime_generator(13)    [23571113]    >>>naive_prime_generator(100)    [2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97]            prime_list =     for x in range (2 n + 1):        if is_prime(x) == True:            prime_list.append(x)    return prime_list,None,0
Wednesday September 11th 2013 2:26 pm -04:00,oops forgot to remove the first precondition for is_prime(n),None,0
Wednesday September 11th 2013 7:28 pm -04:00,Thanks I will try to use this in my code,None,1
Wednesday September 11th 2013 7:53 pm -04:00,Ok here is my sieve of Eratosthenes. Please let me know if it is good. I will work on checking the speed but it seems to be correct. I am not sure if it faster however....def is_prime(n):    (int) -> bool    Returns true if n is a prime number.    Precondition: n must be greater than 2 and an integer    >>> is_prime(13)    True    >>> is_prime(100000007)    True    >>> is_prime(262144)    False            import math    i = int(math.sqrt(n)+1)    if n == 2: return True    else:        for x in range (2 i):            if n % x == 0:                return False    return Truedef index_list(n):    original_list =     for i in range (2 n + 1):        original_list.append(i)    return original_listdef sieve_of_erat(n):    (int) -> list    Returns a list of all the prime integers from 2 to n using the sieve of Eratosenes.    >>>sieve_of_erat(13)    [23571113]    >>>sieve_of_erat(100)     [2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97]        original_list = index_list(n)    for i in original_list:        if is_prime(i) == True:            for x in range (2*i n + 1 i):                if x in original_list:                    original_list.remove(x)    return original_list                ,None,2
