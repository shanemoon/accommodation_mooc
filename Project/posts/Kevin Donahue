Thursday August 29th 2013 11:19 pm -04:00,Thats a great resource. One thing I especially like is the plain english examples once you can use modulo in sentences it starts to make more sense.Whats extra tough to get is how the mod function works for negative numbers. Perhaps it shouldnt have come up in the assignment owing to parameters...although my last function time_from_utc actually does violate that parameter of to_24_hour_clock in some of the examples even. Thanks to how modulos work though I guess it still works just fine.But I did some fiddling and it is quite curious. If were thinking in terms of remainders / normal division it might seem that -1 % 24 would be like -1 or something. But in fact it is 23. So I guess x modulo y is really asking how much greater is x than the nearest multiple of y less than or equal to x?. (Also I guess zero has to like count as a multiple of everything? So that 2 % 3 equals 2.) However my little definition falls apart when the mod part (bottom part? divisor?) is negative. Unlike in normal divison with modular arithmetic it appears that -1 % 24 is different from 1 % -24. The latter results in -23 when I put it into IDLE. My definition above only accounts for positive results from a mod function.I dont really know how to conceptualize what 1 mod negative 24 actually means so I dont really understand the result. Any math-y help would be cool., Resolved,1
Thursday August 29th 2013 11:26 pm -04:00,Actually found good explanations from Kevin Eugensson and Alain Rouleau in the time_from_utc thread. The negative clock example is clear even if I still dont quite get what it actually means., Resolved,1
Wednesday September 25th 2013 9:58 pm -04:00,Thanks a lot for the great course Prof. Gries. and all the community TAs too got an email telling me to thank you.Aliasing is fun I like it. I do have one question though. So in the example above theres no aliasing going on because when y is assigned it is assigned the memory address pointing to the object 3- it doesnt point to the x + 2 expression. Thats cool. And with lists when I assign a variable to a list it is assigned the memory address pointing to that list whatever changes it should undergo.So I was trying this out with functions. I defined a simple function then assigned another variable to that function. Both then operated as the same function IDLE told me they had the same memory address and when I tested their equivalence it came out as True (didnt know you could do that with functions fun fact).But when I then changed the original function the second function I assigned to it did not change with it. The modified original function now pointed to a different memory address and they did not evaluate as equivalent. Even more interestingly when I then re-defined the original function with its original code once again making it match the second function they still did not evaluate as equivalent. That is func1 == func2 was False.So I guess conclusions would be that functions do not do aliasing. But I feel like Im not quite getting the concept fully as it related to objects and memory addresses and whatnot. Is what makes lists alias the fact that the object that variables point to is the list itself which is sort of a level above the objects within that list? Do other things alias?, Resolved,1
